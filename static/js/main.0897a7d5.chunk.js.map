{"version":3,"sources":["components/Header.js","components/DataBar/DataBar.js","components/DataSortingWindow.js","components/AlgoDescriptionContainer.js","components/ColorKeyItem.js","components/SortingStepControls.js","helperFunctions.ts","Algorithms/quickSort.ts","Algorithms/mergeSort.ts","App.js","Algorithms/bubbleSort.ts","Algorithms/selectionSort.ts","Algorithms/insertionSort.ts","Algorithms/heapSort.js","index.js"],"names":["useStyles","makeStyles","theme","horizontalStretch","display","backgroundColor","grey","gridTemplateColumns","Header","algorithm","listOfAlgorithms","algorithmSelected","dataSize","listOfDataSizes","dataSizeSelected","shuffleData","classes","useState","anchorEl","setAnchorEl","dataSizeAnchorEl","setDataSizeAnchorEl","handleClose","handleDataSizeClose","className","root","style","height","AppBar","position","Toolbar","Button","color","title","alignContent","textTransform","aria-label","aria-controls","aria-haspopup","onClick","event","currentTarget","Menu","id","margin","padding","getContentAnchorEl","anchorOrigin","vertical","horizontal","transformOrigin","keepMounted","open","Boolean","onClose","map","name","index","MenuItem","onMouseEnter","e","target","green","onMouseLeave","handleAlgorithmSelection","size","handleDataSizeSelection","variant","DataBar","value","width","styles","container","lightBlue","Box","DataSortingWindow","data","comparing","sorted","swapped","barWidth","flexDirection","gridGap","colorKey","includes","getBarColor","length","minWidth","overflowY","fontSize","pos","AlgoDescriptionContainer","algoName","algoDescription","average","best","worst","Card","CardContent","Typography","component","fontStyle","ColorKeyItem","orb","layout","alignItems","fontFamily","SortingStepControls","handleNextButton","handlePrevButton","sortButton","colorKeys","trackerStep","trackerSize","speed","listOfSpeeds","handleSpeedSelected","justifySelf","buttons","alignSelf","justifyContent","Math","floor","console","log","handleSpeedSelection","key","swap","list","i1","i2","temp","generateRandomUniqueUnorderedList","valueRange","previouslyUsedValues","Set","newValue","random","has","add","push","getSortedIndicesArray","sortedIndices","i","createNewTracker","steps","array","stepDescription","addStepToTracker","tracker","listInstant","step","newStep","QuickSort","sortedIndicesArray","left","right","j","start","end","pivotIndex","pivot","partition","MergeSort","originalList","indexMin","indexMax","slice","comparedIndices","a","leftIndex","rightIndex","overwriteIndex","merge","ALGOINFO","description","performance","ALGORITHMS","lastKnownSortedElementIndex","lastKnownSortedIndex","indexOfSmallestValue","lastVirtuallySortedIndex","indexToInsert","ALGONAMES","algo","DATASIZES","SPEEDS","COLORKEYS","App","overlay","overflowX","sortWindowAndControls","gridTemplateRows","maxHeight","borderRadius","descriptionWindow","algorithmInfo","setAlgorithmInfo","setDataSize","setData","setBarWidth","setTracker","trackerIndex","setTrackerIndex","sortingData","setSortingData","sortedData","setSortedData","sortSpeed","setSortSpeed","getBarWidth","parseInt","getSpecificAlgorithmTracker","duplicateListBecauseJsIsAsynchronous","useEffect","newList","trackerStepSnippetFromIndex","filter","forEach","setTimeout","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0897a7d5.chunk.js","sourcesContent":["import React, {useState} from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Button from '@material-ui/core/Button';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';\nimport green from '@material-ui/core/colors/green';\nimport grey from '@material-ui/core/colors/grey';\n// import indigo from '@material-ui/core/colors/indigo';\n\nconst useStyles = makeStyles((theme) => ({\n//   root: {\n//     flexGrow: 0,\n//   },\n//   menuButton: {\n//     marginRight: theme.spacing(2),\n//   },\n//   title: {\n//     flexGrow: 1,\n//   },\n  horizontalStretch: {\n    display: 'grid',\n    backgroundColor: `${grey[\"900\"]}`,\n    gridTemplateColumns: '1fr auto auto auto',\n    // color: `${indigo[\"200\"]}`,\n  }\n}));\n\nconst Header  = ({algorithm, listOfAlgorithms, algorithmSelected, dataSize, listOfDataSizes, dataSizeSelected, shuffleData}) => {\n    const classes = useStyles();\n    const [anchorEl, setAnchorEl] = useState(null);\n    const [dataSizeAnchorEl, setDataSizeAnchorEl] = useState(null);\n\n    // Control algorithm menu button drop down open&close\n    const handleClick = (event) => {\n      setAnchorEl(event.currentTarget);\n    };\n    const handleClose = () => {\n      setAnchorEl(null);\n    };\n\n    // handles algorithm selection\n    function handleAlgorithmSelection(index) {\n        algorithmSelected(index);\n        handleClose();\n    }\n\n    // Control Data size menu button drop down open&close\n    const handleDataSizeClick = (event) => {\n        setDataSizeAnchorEl(event.currentTarget);\n    };\n    const handleDataSizeClose = () => {\n        setDataSizeAnchorEl(null);\n    }\n\n    // handles data size selection\n    function handleDataSizeSelection(index) {\n        dataSizeSelected(index);\n        handleDataSizeClose();\n    }\n\n    return (\n        <div className={classes.root} style={{height: '64px'}}>\n            <AppBar position=\"fixed\">\n                <Toolbar className={classes.horizontalStretch}>\n\n                    <div>\n                        <Button color=\"inherit\" className={classes.title} >\n                            Sorting Algorithm Visualizer\n                        </Button>\n                    </div>\n\n                    {/* Algorithm Selector Control*/}\n                    <div style={{alignContent: 'center'}}>\n                        <Button \n                            style={{textTransform: 'none'}} \n                            color=\"inherit\" \n                            aria-label=\"menu\" \n                            aria-controls=\"simple-menu\" \n                            aria-haspopup=\"true\" \n                            onClick={handleClick}\n                        >\n                            {algorithm ? algorithm : 'Algorithm'}\n                            <ArrowDropDownIcon />\n                        </Button>\n                        <Menu\n                            id=\"simple-menu\"\n                            style={{margin: '0', padding:'0'}}\n                            anchorEl={anchorEl}\n                            getContentAnchorEl={null}\n                            anchorOrigin={{ vertical: \"bottom\", horizontal: \"center\" }}\n                            transformOrigin={{ vertical: \"top\", horizontal: \"center\" }}\n                            keepMounted\n                            open={Boolean(anchorEl)}\n                            onClose={handleClose}\n                        >\n                            {listOfAlgorithms.map((name, index) => {\n                                return (\n                                    <MenuItem \n                                        onMouseEnter={(e) => e.target.style.backgroundColor = `${green[\"600\"]}`}\n                                        onMouseLeave={(e) => e.target.style.backgroundColor = '#ffffff'}\n                                        key={index} \n                                        onClick={() =>handleAlgorithmSelection(index)}\n                                    >\n                                        {name}\n                                    </MenuItem>\n                                )\n                            })}\n                        </Menu>\n                    </div>\n                  \n                    {/* Data Size Selector Control */}\n                    <div style={{alignContent: 'center'}}>\n                        <Button \n                            style={{textTransform: 'none'}} \n                            color=\"inherit\" \n                            aria-label=\"menu\" \n                            aria-controls=\"simple-menu\" \n                            aria-haspopup=\"true\" \n                            onClick={handleDataSizeClick}\n                        >\n                            {dataSize} Elements\n                            <ArrowDropDownIcon />\n                        </Button>\n                        <Menu\n                            id=\"simple-menu\"\n                            anchorEl={dataSizeAnchorEl}\n                            getContentAnchorEl={null}\n                            anchorOrigin={{ vertical: \"bottom\", horizontal: \"center\" }}\n                            transformOrigin={{ vertical: \"top\", horizontal: \"center\" }}\n                            keepMounted\n                            open={Boolean(dataSizeAnchorEl)}\n                            onClose={handleDataSizeClose}\n                        >\n                            {listOfDataSizes.map((size, index) => {\n                                return (\n                                    <MenuItem \n                                        onMouseEnter={(e) => e.target.style.backgroundColor = `${green[\"600\"]}`}\n                                        onMouseLeave={(e) => e.target.style.backgroundColor = '#ffffff'}    \n                                        key={index} \n                                        onClick={() =>handleDataSizeSelection(index)}\n                                    >\n                                        {size}\n                                    </MenuItem>\n                                )\n                            })}\n                        </Menu>\n                    </div>\n\n                    <Button color=\"inherit\" variant=\"outlined\" style={{textTransform: 'none'}} onClick={() => shuffleData()}>\n                        Shuffle Data\n                    </Button>\n                </Toolbar>\n            </AppBar>\n         </div>\n    )\n}\n\nexport default Header;","import React from 'react';\nimport './DataBar.css';\nimport Box from '@material-ui/core/Box';\nimport lightBlue from '@material-ui/core/colors/lightBlue';\n\nconst DataBar = ({value, width, dataSize, color}) => {\n    const styles = {\n        container: {\n            backgroundColor: `${color? color : lightBlue[\"600\"]}`,\n            height: `${getHeight()}`,\n            width: `${width}`,\n        }\n    }\n\n    function getHeight() {\n        if (dataSize < 10) {\n            return `${(30*value)}px`;\n        } else if(dataSize < 25) {\n            return `${(20*value)}px`;\n        } else if (dataSize === 25) {\n            return `${(8*value)}px`;\n        } else if (dataSize === 50 ) {\n            return `${(3.9*value)}px`;\n        } else {\n            return `${(2*value)}px`;\n        }\n    }\n    return (\n        <Box className=\"data-bar\" style={styles.container} />\n    )\n}\n\nexport default DataBar;","import React from 'react';\nimport DataBar from './DataBar/DataBar.js';\nimport green from '@material-ui/core/colors/green';\n\n// In order to display the array as a list of bars of varying heights we need to make the css dynamic\n// The width of the window is constant so we need to set the widths of each bar depending on data size\n// Need a formula for constructing individual bars depending on data size, and value. Value to height conversion will be constant ? but width to data size will not \n// Since it's dynamic, when swapping data points it needs to support each algorithm by highlighting the data points being compared and then recalculating the height of the bars in place as the swap happens at the parent level\n// Will have a fixed set of bar components, the size will just vary ... will need a way other than .map? If you .map every swap that kinda defeats the purpose even if the algorithm itself isn't doing that..... \n// You can pass the indexes in of what's being compared/what ends up being swapped, so you could access each data point at O(1), but how do you do that with .map?\n// You could just bite the bullet and use .map, and send an updated array everytime so this component will be recalculating the bars constantly as the algorithm runs. With large data it could be sus\n// How to pass information to the window that elements have been sorted vs. are being comapred vs. are unsorted?\nconst DataSortingWindow = ({data, comparing, sorted, swapped, barWidth}) => {\n    const styles = {\n        graph: {\n            display: 'flex',\n            flexDirection: 'row',\n            width: '100%',\n            gridGap: '4px'\n        }\n    }\n\n    // checking the comparing, sorted, and swapped arrays from the dataSortingList - if the index value is present in any of these, return the corresponding color key\n    function getBarColor(index) {\n        if (comparing && comparing.includes(index)) {\n            return 'yellow';\n        } else if (swapped && swapped.includes(index)) {\n            return 'red';\n        } else if (sorted && sorted.includes(index)) {\n            return `${green[\"600\"]}`;\n        } else  {\n            return null;\n        }\n    }\n    \n    return (\n        <div style={styles.graph}>\n            {data? data.map((value, index) => {\n                const colorKey = getBarColor(index);\n                return (\n                    <DataBar key={index} value={value} width={barWidth} color={colorKey} dataSize={data.length}/>\n                )\n            }) : null}\n        </div>\n    )\n}\n\nexport default DataSortingWindow;","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\n\nimport Card from '@material-ui/core/Card';\nimport CardActions from '@material-ui/core/CardActions';\nimport CardContent from '@material-ui/core/CardContent';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\n\nconst useStyles = makeStyles({\n    root: {\n      minWidth: 250,\n      overflowY: 'scroll'\n    },\n    title: {\n      fontSize: 16,\n    },\n    pos: {\n    //   marginBottom: 12,\n    },\n  });\n\nconst AlgoDescriptionContainer = ({algoName, algoDescription, average, best, worst}) => {\n    // const styles = {\n    //     container: {\n    //         display: 'grid',\n    //         // gridGap: '3px',\n    //         font: 'Roboto'\n    //     }\n    // }\n    const classes = useStyles();\n\n    return (\n        <Card className={classes.root}>\n        <CardContent>\n            <Typography variant=\"h4\" component=\"h2\">\n                {algoName? algoName : 'Select Algorithm'}\n                <br />\n            </Typography>\n            <br/>\n            <Typography variant=\"body2\" component=\"p\">\n                {algoDescription? algoDescription : 'You must select an algorithm in order to visualize how it sorts the data'}\n                <br />\n            </Typography>\n            <br />\n            <Typography variant=\"h6\" component=\"h4\" >\n                Performance\n                <br />\n            </Typography>\n            <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr'}}>\n                <Typography variant=\"body2\" component=\"p\">\n                    Best\n                    <br />\n                    Average\n                    <br />\n                    Worst \n                </Typography>\n\n                <Typography variant=\"body2\" component=\"p\" style={{fontStyle: 'italics'}}>\n                    {best}\n                    <br />\n                    {average}\n                    <br />\n                    {worst}\n                </Typography>\n            </div>\n            \n        </CardContent>\n\n        {/* <CardActions>\n            <Button size=\"small\" href=\"wikipedia.com\">Learn More</Button>\n        </CardActions> */}\n\n        </Card>\n    )\n}\n\nexport default AlgoDescriptionContainer;","import React from 'react';\nimport Brightness1 from '@material-ui/icons/Brightness1';\nimport Typography from '@material-ui/core/Typography';\n\nconst ColorKeyItem = ({color, colorKey}) => {\n    const styles = {\n        orb: {\n            color: `${color}`\n        },\n        layout: {\n            display: 'inline-grid',\n            gridTemplateColumns: 'auto auto',\n            gridGap: '5px',\n            padding: '8px',\n            alignItems: 'center',\n            color: 'white',\n            fontFamily: 'Roboto'\n        }\n    }\n    return (\n        <div style={styles.layout}>\n            <Brightness1 style={styles.orb} />\n            <Typography>\n                {colorKey}\n            </Typography>\n        </div>\n    )\n}\n\nexport default ColorKeyItem;","import React, {useState} from 'react';\nimport Typography from '@material-ui/core/Typography'\nimport ColorKeyItem from './ColorKeyItem.js';\nimport Button from '@material-ui/core/Button';\nimport SkipPrevious from '@material-ui/icons/SkipPrevious'\nimport SkipNext from '@material-ui/icons/SkipNext';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';\nimport green from '@material-ui/core/colors/green';\n\nconst SortingStepControls = ({ handleNextButton, handlePrevButton, sortButton, colorKeys, trackerStep, trackerSize, speed, listOfSpeeds, handleSpeedSelected }) => {\n    const styles = {\n        speed: {\n            \n        },\n        layout: {\n            padding: '15px',\n            display: 'grid',\n            gridTemplateColumns: '1fr',\n            gridGap: '15px',\n            alignItems: 'center',\n            justifySelf: 'center'\n        },\n        buttons: {\n            display: 'flex',\n            justifySelf: 'center',\n            alignSelf: 'center',\n            justifyContent: 'center',\n            color: 'white'\n        }\n    }\n\n    const [anchorEl, setAnchorEl] = useState(null);\n\n    // Control speed menu button drop down open&close\n    const handleClick = (event) => {\n        setAnchorEl(event.currentTarget);\n      };\n    const handleClose = () => {\n    setAnchorEl(null);\n    };\n\n    function handleSpeedSelection(index) {\n        handleClose();\n        handleSpeedSelected(index);\n        console.log('speed selection index: ', index);\n    }\n\n\n    function getTrackerProgress() {\n        return `${Math.floor((trackerStep/trackerSize)*100)}%`;\n    }\n    return (\n        <div style={styles.layout}>\n\n            <div style ={styles.buttons}>\n                <Typography style={{color: 'white', alignSelf: 'center'}}>\n                    {trackerSize ? getTrackerProgress() : '0%'}\n                </Typography>\n\n                <Button>\n                    <SkipPrevious style={{color: 'white'}} onClick={() => handlePrevButton()}/>\n                </Button>\n\n                <Button color=\"inherit\" variant=\"outlined\" style={{color: 'white'}} onClick = {() => sortButton()}>\n                    SORT\n                </Button>\n\n                <Button onClick={() => handleNextButton()}>\n                    <SkipNext style={{color: 'white'}}  />\n                </Button>\n\n                {/* Speed drop down selector */}\n                <div style={{alignContent: 'center'}}>\n                        <Button \n                            style={{textTransform: 'none'}} \n                            color=\"inherit\" \n                            aria-label=\"menu\" \n                            aria-controls=\"simple-menu\" \n                            aria-haspopup=\"true\" \n                            onClick={handleClick}\n                        >\n                            {speed}x\n                            <ArrowDropDownIcon />\n                        </Button>\n                        <Menu\n                            id=\"simple-menu\"\n                            style={{margin: '0', padding:'0'}}\n                            anchorEl={anchorEl}\n                            getContentAnchorEl={null}\n                            anchorOrigin={{ vertical: \"bottom\", horizontal: \"center\" }}\n                            transformOrigin={{ vertical: \"top\", horizontal: \"center\" }}\n                            keepMounted\n                            open={Boolean(anchorEl)}\n                            onClose={handleClose}\n                        >\n                            {listOfSpeeds.map((speed, index) => {\n                                return (\n                                    <MenuItem \n                                        onMouseEnter={(e) => e.target.style.backgroundColor = `${green[\"600\"]}`}\n                                        onMouseLeave={(e) => e.target.style.backgroundColor = '#ffffff'}\n                                        key={index} \n                                        onClick={() =>handleSpeedSelection(index)}\n                                    >\n                                        {speed}x\n                                    </MenuItem>\n                                )\n                            })}\n                        </Menu>\n                    </div>\n            </div>\n\n            <div>\n                {colorKeys.map((key, index) => {\n                    return (\n                        <ColorKeyItem key={index} colorKey={key.key} color={key.color} />\n                    )\n                })}\n            </div>\n            \n        </div>\n    )\n}\n\nexport default SortingStepControls;","import {Tracker, TrackerStep} from './IterationTrackerInterface';\n// swaps values in an array at the two indexes\nexport function swap(list:Array<number>, i1:number, i2:number):void {\n    const temp:number = list[i1];\n    list[i1] = list[i2];\n    list[i2] = temp;\n}\n\n// generates an array of data points that are unique and unordered. Range of values is 3* the request list length to give an adequate range of values.\nexport function generateRandomUniqueUnorderedList(size:number):Array<number> {\n    const valueRange = size*2;\n    let previouslyUsedValues:Set<number> = new Set<number>();\n    let list = [];\n\n    while(list.length !== size) {\n        let newValue = Math.floor(Math.random()*valueRange);\n        if (!previouslyUsedValues.has(newValue) && newValue !== 0 && newValue >= .1 * valueRange) {\n            previouslyUsedValues.add(newValue);\n            list.push(newValue);\n        }\n    }\n    console.log('NEW randomized list generated: ', list);\n    return list;\n}\n\n// creates an array from indicies from 0 up to the specified length-1 for algorithms that don't sort everything until the end\nexport function getSortedIndicesArray(length:number):Array<number> {\n    let sortedIndices:Array<number> = [];\n    for (let i=0; i<length; i++) {\n        sortedIndices.push(i);\n    }\n    return sortedIndices;\n}\n\n// creates a NEW tracker object where each index in the steps array is a step in the algorithm.\nexport function createNewTracker(list:Array<number>):Tracker {\n    let tracker:Tracker = {\n        steps: [{\n            array: list,\n            sortedIndices: [],\n            comparing: [],\n            swapped: [],\n            stepDescription: 'added list to tracker'\n        }]\n    };\n    \n    return tracker;\n}\n\n// this adds a step to the tracker object for each new step in a sorting algorithm. It is a snapshot in time that stores the data, compared indices, sorted indices, and swapped indices at each specific instant of time\nexport function addStepToTracker(tracker:Tracker, listInstant:Array<number>, comparing:Array<number>, sorted:Array<number>, swapped:Array<number>, step:string) {\n    const newStep:TrackerStep = {\n        array: listInstant,\n        sortedIndices: sorted,\n        comparing: comparing,\n        swapped: swapped,\n        stepDescription: step\n    }\n    tracker.steps.push(newStep);\n}\n\n// TO DO - add functionality for selecting and coloring the pivot element at each partition of quick sort. Currently it's in the comparing category. \n// Need to update app.js to handle datasortingwindow.js to handle a pivot array, create a new interface for quicksorttrackerstep that includes different names maybe? \n \n// export function quickSortAddStepToTracker(tracker:Tracker, listInstant:Array<number>, pivotIndex: Array<number>, )","import { createNewTracker, addStepToTracker, getSortedIndicesArray, swap } from '../helperFunctions';\nimport { Tracker } from '../IterationTrackerInterface';\n\nexport const QuickSortMain = (list:Array<number>):Tracker => {\n    let tracker:Tracker = createNewTracker([...list]);\n    let sortedIndicesArray:Array<number> = [];\n    QuickSort(list, tracker, sortedIndicesArray, 0, list.length-1);\n\n    addStepToTracker(tracker, list, [], getSortedIndicesArray(list.length), [], 'sorted list');\n    return tracker;\n}\n\n\nfunction QuickSort(list:Array<number>, tracker:Tracker, sortedIndicesArray:Array<number>, left:number, right:number) {\n    if (left < right) {\n        let j = partition(list, tracker, sortedIndicesArray, left, right);\n        sortedIndicesArray.push(j);\n        addStepToTracker(tracker, [...list], [], [...sortedIndicesArray], [], 'post partition');\n        QuickSort(list, tracker, sortedIndicesArray, left, j-1);\n        QuickSort(list, tracker, sortedIndicesArray, j+1, right);\n    } else {\n        sortedIndicesArray.push(left);\n        addStepToTracker(tracker, [...list], [], [...sortedIndicesArray], [], 'base case, only one element - add to sorted');\n    }\n}\n\nfunction partition(list:Array<number>, tracker:Tracker, sortedIndicesArray:Array<number>, start:number, end:number):number {\n    const pivotIndex = start; // set pivot to first index of the list \n    let pivot = list[pivotIndex];\n    addStepToTracker(tracker, [...list], [pivotIndex], [...sortedIndicesArray], [], `adding pivot to tracker. Pivot VALUE: ${pivot}`);\n    let i = pivotIndex+1;\n    let j = end;\n\n    while (i < j) {\n        while (list[i] < pivot) {\n            addStepToTracker(tracker, [...list], [pivotIndex, i], [...sortedIndicesArray], [], 'incrementing i');\n            i++;\n            if (list[i] > pivot) addStepToTracker(tracker, [...list], [pivotIndex], [...sortedIndicesArray], [i], 'next i value breaks while loop, value at i is GREATER than pivot');\n        }\n        while (list[j] > pivot) {\n            addStepToTracker(tracker, [...list], [pivotIndex, j], [...sortedIndicesArray], [], 'incrementing j');\n            j--;\n            if (list[j] < pivot) addStepToTracker(tracker, [...list], [pivotIndex], [...sortedIndicesArray], [j], 'next j value breaks while loop, value at j is LESS than pivot');\n\n        }\n\n        addStepToTracker(tracker, [...list], [pivotIndex, i, j], [...sortedIndicesArray], [], 'after i and j increment')\n\n\n        if (i<j) {\n            swap(list, i, j);\n            addStepToTracker(tracker, [...list], [pivotIndex], [...sortedIndicesArray], [i, j], 'swapped i and j');\n        }\n    }\n    if (list[j] < pivot) {\n        swap(list, j, pivotIndex);\n    }\n    return j;\n\n}\n\n\n\nexport const quickSortInfo = {\n    name: 'Quick Sort',\n    description: 'Quick sort runs on the basis of sorting elements around a pivot that can be randomly selected, or at the beginning/end of the array. At each call of the algorithm, the array is partitioned in two by swapping all elements smaller than the pivot with elements larger than the pivot, then swapping the pivot with the largest element that is smaller than the pivot. This effectively places the pivot in its final sorted position since all the elements are smaller and all elements after are greater. This method is called recursively with the remaining subarrays until all elements are sorted. It is the most popular sorting algorithm that handles relatively small data sizes incredibly well. In this variation of quick sort, the first element is selected as the pivot and then two pointers iterate through the rest of the subarray, one from the left, one from the right. Both pointers iterate into one another until they reach a value that is unsorted  relative to the pivot, or the pointers cross. For the left pointer, it will stop when it reaches a value that is greater than the pivot, and the right pointer will stop when it reaches a value that is less than the pivot. Once the pointers stop the values will be swapped, and the pointers continue.',\n    performance: {\n        best: 'O(nlog n)',\n        average: 'O(nlog n)',\n        worst: 'O(n^2)'\n    },\n    index: 3\n}","import { createNewTracker, addStepToTracker, getSortedIndicesArray } from '../helperFunctions';\nimport { Tracker } from '../IterationTrackerInterface';\n\n// need to initialize tracker and pass to this function since it's recursive\n\nexport const MergeSortMain = (list:Array<number>):Tracker => {\n    let tracker:Tracker = createNewTracker([...list]);\n    MergeSort(list, tracker, [...list], 0, list.length-1);\n\n    addStepToTracker(tracker, list, [], getSortedIndicesArray(list.length), [], 'finished sorting');\n\n    console.log('sorted list!: ', list);\n    return tracker;\n\n}\n\n// need to keep the tracker, original list, and the array of values being compared/swapped - how to grab indexes of the sublists? keep track of min and max index of the sub lists\nfunction MergeSort(list:Array<number>, tracker:Tracker, originalList:Array<number>, indexMin:number, indexMax:number) {\n    if (list.length > 1) {\n        let left:Array<number> = list.slice(0, list.length/2);\n        let right:Array<number> = list.slice(list.length/2, list.length);\n\n        let comparedIndices:Array<number> = [];\n        for (let i=indexMin; i<=indexMax; i++) {\n            comparedIndices.push(i);\n        }\n        addStepToTracker(tracker, [...originalList], comparedIndices, [], [], 'list passed to merge sort');\n\n        // since left and right are sorted with the same original list instant passed, after the left side sorts, the right side has unsorted left side data even though the left side is sorted. \n        // the right side doesnt wait for the right side to sort and then grab the sorted left half. How to get it to wait, and then grab the sorted result for the right sort? --> it DOES wait in the call stack. But the value you passed it originally was the copy at the instant, instead of the pointer which will point to the edited object after the left side calls. Need to send the pointer to the object to the recursive call for this to work.\n        // You CANNOT send the copy of the instant to merge sort, you need to send the actual object because it is being edit on each call!!!! You pass in the instant only when you add to the tracker!\n        MergeSort(left, tracker, originalList, indexMin, indexMin + left.length-1); // keep track of the index range for each subarray passed to merge sort so you know which indexes to overwrite.\n        MergeSort(right, tracker, originalList, indexMin + left.length, indexMax);\n\n\n        merge(list, left, right, tracker, originalList, indexMin); \n        addStepToTracker(tracker, [...originalList], [], [], [], 'merged');\n    }\n}\n\nfunction merge(a:Array<number>, left:Array<number>, right:Array<number>, tracker:Tracker, originalList:Array<number>, indexMin:number) {\n    let leftIndex = 0;\n    let rightIndex = 0; \n    let overwriteIndex = indexMin;\n\n    for (let i=0; i<a.length; i++) {\n        if (rightIndex >= right.length || (left[leftIndex] < right[rightIndex] && leftIndex < left.length)) {\n            a[i] = left[leftIndex];\n            leftIndex++;\n            originalList[overwriteIndex++] = a[i]; // overwrite the array at the index\n        } else {\n            a[i] = right[rightIndex];\n            rightIndex++;\n            originalList[overwriteIndex++] = a[i];\n        }\n\n        addStepToTracker(tracker, [...originalList], [], [], [overwriteIndex - 1], 'overwrite from new array a');\n\n    }\n\n}\n\n\nexport const mergeSortInfo = {\n    name: 'Merge Sort',\n    description: 'Merge sort is a recursive sorting algorithm that handles large data very efficiently by using the divide and conquer method. It runs on the idea of merging two lists that are each sorted relative to itself. Imagine you have two stacks of papers that are both alphabetically ordered and you want to combine the two stacks to be alphabetically ordered. You look at the top two papers and grab the earlier one in the alphabet and place it in a third pile. You then grab the next paper from the stack whose top paper you just put on the third pile and compare it to the other paper that you grabbed at first and continue this until one stack runs out. At this point you can put the rest of the remaining stack on the third pile and you have merged the stacks. Merge sort works on a similar principle by continually making subarrays within the list and merging them until you get the final sorted list.',\n    performance: {\n        best: 'O(nlog n)',\n        average: 'O(nlog n)',\n        worst: 'O(nlog n)'\n    },\n    index: 4\n}","import React, {useState, useEffect} from 'react';\n\n// Custom Components\nimport Header from './components/Header.js';\nimport DataSortingWindow from './components/DataSortingWindow.js';\nimport AlgoDescriptionContainer from './components/AlgoDescriptionContainer.js';\nimport SortingStepControls from './components/SortingStepControls.js';\n\n// Interface\n// import {Tracker} from './IterationTrackerInterface.ts';\n\n// Algorithms\nimport {bubbleSortInfo, BubbleSort} from './Algorithms/bubbleSort.ts';\nimport {selectionSortInfo, SelectionSort} from './Algorithms/selectionSort.ts';\nimport {insertionSortInfo, InsertionSort} from './Algorithms/insertionSort.ts';\nimport {quickSortInfo, QuickSortMain} from './Algorithms/quickSort.ts';\nimport {mergeSortInfo, MergeSortMain} from './Algorithms/mergeSort.ts';\nimport {heapSortInfo} from './Algorithms/heapSort.js';\n\n// Material ui\n// import indigo from '@material-ui/core/colors/indigo';\nimport green from '@material-ui/core/colors/green';\nimport grey from '@material-ui/core/colors/grey';\nimport lightBlue from '@material-ui/core/colors/lightBlue';\n\n// Utility\nimport {generateRandomUniqueUnorderedList} from './helperFunctions.ts'; // still works!\n\n// Application CONSTANTS\nconst ALGOINFO = [\n    bubbleSortInfo,\n    selectionSortInfo,\n    insertionSortInfo,\n    quickSortInfo,\n    mergeSortInfo,\n    heapSortInfo\n]\n\nconst ALGORITHMS = [\n    BubbleSort,\n    SelectionSort,\n    InsertionSort,\n    QuickSortMain,\n    MergeSortMain\n]\n\nconst ALGONAMES = ALGOINFO.map(algo => algo.name);\nconst DATASIZES = ['5', '10', '25', '50', '100'];\nconst SPEEDS = ['0.25', '0.5', '1.0', '2.0', '4.0'];\n\nconst COLORKEYS = [{\n        key: 'Unsorted', \n        color: `${lightBlue[\"600\"]}`\n    }, {\n        key: 'Comparing',\n        color: 'yellow'\n    }, {\n        key: 'Swapped',\n        color: 'red'\n    }, {\n        key: 'Sorted',\n        color: `${green[\"600\"]}`\n    }\n];\n\n\n// Controls the program, grabs the algorithm and data size that are selected, runs/stops the algorithm, sends data points to child component, renders relevant data \nconst App = () => {\n    const styles = {\n        overlay: { // need this AND <style> in index.html to make the div FULL screen!!\n            backgroundColor: `${grey[\"900\"]}`,\n            position: 'fixed',\n            width: '100%',\n            height: '100%',\n            display: 'grid',\n            overflowY: 'scroll',\n            overflowX: 'scroll'\n        }, \n        layout: {\n            display: 'grid',\n            gridTemplateColumns: '5fr 2fr',\n            gridGap: '50px',\n            height: '500px',\n            padding: '0px 50px 50px 50px',\n        },\n        sortWindowAndControls: {\n            display: 'grid',\n            gridTemplateRows: '10fr 1fr',\n            maxHeight: '525px',\n            width: '100%',\n            borderRadius: '10px',\n            padding: '15px',\n            backgroundColor: `${grey[\"800\"]}`,\n            color: `${green[\"600\"]}`,\n        },\n        descriptionWindow: {\n            display: 'grid',\n            overflowY: 'scroll',\n            borderRadius: '10px',\n            padding: '15px',\n            backgroundColor: `${grey[\"800\"]}`,\n            color: `${green[\"600\"]}`,\n        }\n    }\n\n    const [algorithmInfo, setAlgorithmInfo] = useState({\n        name: '',\n        description: '',\n        performance: {\n            best: '',\n            average: '',\n            worst: ''\n        },\n        index: null\n    })\n    const [dataSize, setDataSize] = useState('10');\n    const [data, setData] = useState(null);\n    const [barWidth, setBarWidth] = useState('');\n    const [tracker, setTracker] = useState({\n        steps: []\n    })\n    let [trackerIndex, setTrackerIndex] = useState(0);\n    const [sortingData, setSortingData] = useState({\n        array: [],\n        comparing: [],\n        sortedIndices: [],\n        swapped: []\n    }); // the data that's initially a deep copy of data then iterates through tracker.steps - this is what's sent to the data sorting window\n    const [sortedData, setSortedData] = useState(null); // sorted array stored as soon as sorting algo is selected ahead of time to check\n    const [sortSpeed, setSortSpeed] = useState(SPEEDS[2]);\n\n    useEffect(() => {\n        setDataSize('10');\n        setData(generateRandomUniqueUnorderedList(10));\n        setSortingData(null);\n    }, []);\n\n    useEffect(() => {\n        setBarWidth(getBarWidth(dataSize));\n    }, [dataSize])\n\n    function getBarWidth() {\n        switch(parseInt(dataSize)) {\n            case 5:\n                return '20%';\n            case 10:\n                return '10%';\n            case 25:\n                return '4%';\n            case 50: \n                return '2%';\n            case 100:\n                return '1%';\n            default: \n                return '5%';\n        }\n    }\n    \n    /* functions for managing the tracker */\n    function run() {\n        const trackerStepSnippetFromIndex = tracker.steps.filter((step, index) => index >= trackerIndex )\n\n        console.log(trackerIndex);\n        console.log(trackerStepSnippetFromIndex);\n\n        trackerStepSnippetFromIndex.forEach((step, index) => {\n            setTimeout(() => {\n                setSortingData(step);\n                setTrackerIndex(trackerIndex++);\n                if (index === trackerStepSnippetFromIndex.length-1) {\n                    setTrackerIndex(trackerIndex++);\n                }\n            }, (150 * (1/sortSpeed)) * index);\n        });\n        \n        setTrackerIndex(tracker.steps.length);\n    }\n\n    function speedSelected(index) {\n        setSortSpeed(SPEEDS[index]);\n    }\n\n\n    function handlePreviousStep() {\n        if (sortingData !== data) {\n            setTrackerIndex(trackerIndex - 1);\n            setSortingData(tracker.steps[trackerIndex - 1]);\n        }\n    }\n\n    function handleNextStep() {\n        if (sortingData !== sortedData) {\n            setTrackerIndex(trackerIndex + 1);\n            setSortingData(tracker.steps[trackerIndex + 1]);\n        }\n    }\n    \n    /* functions for algorithm selection, element size, shuffling, and execution */\n    function handleAlgorithmSelection(index) {\n        setAlgorithmInfo(ALGOINFO[index]);\n\n        getSpecificAlgorithmTracker(index, sortingData? sortingData.array : data); // for some reason, without this it will send the sorted list - so when you click the same alogirthm twice it solves it automatically. needs investigation but this fixes it\n\n    }\n\n    function handleListSizeSelection(index) {\n        console.log('Data size changed - data size: ', DATASIZES[index]);\n        setSortingData(null); // sorting data is only sent to child once the algorithm runs and we have the tracker\n\n        setDataSize(DATASIZES[index]);\n        setBarWidth(getBarWidth(DATASIZES[index]));\n        const newList = generateRandomUniqueUnorderedList(parseInt(DATASIZES[index]));\n        setTrackerIndex(0);\n        \n        setData(newList);\n        if (algorithmInfo.index !== null) {\n            getSpecificAlgorithmTracker(algorithmInfo.index, newList);\n        }\n    }\n\n    function shuffleDataRequest() {\n        setSortingData(null);\n        setTrackerIndex(0);\n        const newList = generateRandomUniqueUnorderedList(parseInt(dataSize));\n        setData(newList);\n        if (algorithmInfo.index !== null) {\n            getSpecificAlgorithmTracker(algorithmInfo.index, newList);\n        }\n    }\n\n    // The steps for an algorithm are stored in a tracker object which has an array of steps that are iterated to display the algorithm visually\n    // need to pass the new unique array to this function to get a tracker of the updated list since JS is asynchornous - it doesnt grab the setData() value from the functions before it so it calculates the tracker for the list before the size was changd/shuffle button was clicked\n    function getSpecificAlgorithmTracker(index, duplicateListBecauseJsIsAsynchronous) {\n        console.log(index);\n        let tracker;\n        \n        if (algorithmInfo.index === null || index !== algorithmInfo.index) { // either first time selecting an algorithm or selecting a new one\n            tracker = ALGORITHMS[index](duplicateListBecauseJsIsAsynchronous); \n        } else { // in the case that the same algorithhm is selected\n            tracker = ALGORITHMS[algorithmInfo.index](duplicateListBecauseJsIsAsynchronous); \n        }\n\n        setTracker(tracker);\n        console.log(`NEW Tracker generated using ${ALGOINFO[index].name}`,tracker);\n\n        setSortedData(tracker.steps[tracker.steps.length-1].array);\n        setSortingData(tracker.steps[0]);\n    }\n\n\n    return (\n        <div style={styles.overlay}>\n            <Header \n                algorithm={algorithmInfo.name} \n                listOfAlgorithms={ALGONAMES} \n                algorithmSelected={handleAlgorithmSelection}\n                dataSize={dataSize}\n                listOfDataSizes={DATASIZES}\n                dataSizeSelected={handleListSizeSelection}\n                shuffleData={shuffleDataRequest}\n            />\n\n            <div style={styles.layout}>\n                <div style={styles.sortWindowAndControls}>\n                    <DataSortingWindow \n                        data={sortingData? sortingData.array : data} \n                        comparing={sortingData? sortingData.comparing : null}\n                        swapped={sortingData? sortingData.swapped : null}\n                        sorted={sortingData? sortingData.sortedIndices : null}\n                        barWidth={barWidth}\n                    />\n\n                    <SortingStepControls \n                        handleNextButton={handleNextStep}\n                        handlePrevButton={handlePreviousStep}\n                        sortButton={run}\n                        colorKeys={COLORKEYS} // set to algorithm specific color key! For quick and prob heap sort. \n                        trackerSize={tracker.steps.length}\n                        trackerStep={trackerIndex}\n                        speed={sortSpeed}\n                        listOfSpeeds={SPEEDS}\n                        handleSpeedSelected={speedSelected}\n                    />\n                </div>\n                \n                <AlgoDescriptionContainer\n                    algoName={algorithmInfo.name}\n                    algoDescription={algorithmInfo.description}\n                    average={algorithmInfo.performance.average}\n                    best={algorithmInfo.performance.best}\n                    worst={algorithmInfo.performance.worst}\n                />\n            </div>\n        </div>\n    )\n}\n\nexport default App;","import { swap, createNewTracker, addStepToTracker } from '../helperFunctions';\nimport { Tracker } from '../IterationTrackerInterface';\n\nexport const BubbleSort = (list: Array<number>):Tracker => {\n    console.log('list sent to bubble sort', list);\n    let tracker:Tracker = createNewTracker([...list]);// need to send deep copy of the list before it sorts or else every step of the tracker will have the same array - the final sorted array, because they're all pointing to the same object! \n    let sortedIndices:Array<number> = [];\n\n    for(let lastKnownSortedElementIndex = list.length-1; lastKnownSortedElementIndex>=1; lastKnownSortedElementIndex--) { // outer loop, need to run swapping algorithm up to last known sorted element -1; with this algorithm the elements are sorted right to left\n        if(lastKnownSortedElementIndex< list.length-1) {\n            sortedIndices.push(lastKnownSortedElementIndex+1);\n            addStepToTracker(tracker, [...list], [], [...sortedIndices], [], 'last known sorted el is less than the end');\n        }\n        \n\n        for (let i=0; i<lastKnownSortedElementIndex; i++) { // inner loop running the swap algorithm from the first index to the last known sorted element -1;\n            addStepToTracker(tracker, [...list], [i, i+1], [...sortedIndices], [], 'new iteration of i'); // comparing values at index i and i+1\n\n            if(list[i] > list[i+1]) { // if left value is greater than right value, SWAP them. If i\n                swap(list, i, i+1);\n                addStepToTracker(tracker, [...list], [], [...sortedIndices], [i, i+1], 'AFTEr swapping');\n            }\n        }\n    }\n\n    // Need to add the final step with the same array to updated the sorted values for colors. Without this, it colors the last comparison yellow\n    while (list.length !== sortedIndices.length) {\n        sortedIndices.push(list.length-sortedIndices.length - 1);\n    }\n\n    addStepToTracker(tracker, list, [], sortedIndices, [], 'FINISHED SORTING');\n    console.log('sorted list! ', list);\n    return tracker;\n\n}\n\nexport const bubbleSortInfo = {\n    name: 'Bubble Sort',\n    description: 'Bubble sort is a simple sorting algorithm that compares adjacent elements and swaps them if they are in the wrong order. It sorts from right to left, with each pass of the algorithm grabbing the next-highest value in the list until the entire list is sorted. It is called bubble sort because of the way the algorithm makes the largest/smallest values bubble up to the end of the list depending on which orientation the user desires the list to be in (ascending/descending).',\n    performance: {\n        best: 'O(n)',\n        average: 'O(n^2)',\n        worst: 'O(n^2)'\n    },\n    index: 0\n}\n\n \n// get name, get description, somehow get the algorithm and visually edit and show the data that's passed to it...\n","import { swap, createNewTracker, addStepToTracker } from '../helperFunctions';\nimport { Tracker } from '../IterationTrackerInterface';\n\nexport const SelectionSort = (list: Array<number>):Tracker => {\n    console.log('list sent to selection sort: ', list);\n    let tracker:Tracker = createNewTracker([...list]);\n    let sortedIndices:Array<number> = [];\n\n    for (let lastKnownSortedIndex = -1; lastKnownSortedIndex < list.length; lastKnownSortedIndex++) {\n        let indexOfSmallestValue = lastKnownSortedIndex + 1;\n\n        if(lastKnownSortedIndex > -1) {\n            sortedIndices.push(lastKnownSortedIndex);\n            addStepToTracker(tracker, [...list], [], [...sortedIndices], [], 'after one pass of the algorithm')\n        }\n\n        for (let i=lastKnownSortedIndex + 1; i<list.length; i++) {\n            addStepToTracker(tracker, [...list], [i, indexOfSmallestValue], [...sortedIndices], [], 'increment of i, comparing inner loop values to selected value');\n\n            if (list[i] < list[indexOfSmallestValue]) { // new selected lowest value\n                swap(list, i, indexOfSmallestValue);\n\n                addStepToTracker(tracker, [...list], [], [...sortedIndices], [i, indexOfSmallestValue], 'lowest value swapped with beginning of last known sorted index');\n            }\n        }\n\n    }\n\n    addStepToTracker(tracker, list, [], sortedIndices, [], 'FINISHED SORTING');\n\n    console.log('sorted list!', list);\n    return tracker;\n}\n\nexport const selectionSortInfo = {\n    name: 'Selection Sort',\n    description: 'Selection sort is an in-place comparison sorting algorithm that divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.',\n    performance: {\n        best: 'O(n^2)',\n        average: 'O(n^2)',\n        worst: 'O(n^2)'\n    },\n    index: 1\n}","import { swap, createNewTracker, addStepToTracker, getSortedIndicesArray } from '../helperFunctions';\nimport { Tracker } from '../IterationTrackerInterface';\n\nexport const InsertionSort = (list:Array<number>):Tracker => {\n    console.log('list sent to insertion sort', list);\n    let tracker:Tracker = createNewTracker([...list]);\n\n    for (let lastVirtuallySortedIndex = 1; lastVirtuallySortedIndex < list.length; lastVirtuallySortedIndex++) {\n        let indexToInsert = lastVirtuallySortedIndex;\n\n        if (lastVirtuallySortedIndex > 1) {\n            addStepToTracker(tracker, [...list], [], [], [], 'element inserted to virutal sorted list');\n        }\n\n        while ((list[indexToInsert] < list[indexToInsert - 1]) &&  indexToInsert > 0) {\n            addStepToTracker(tracker, [...list], [indexToInsert, indexToInsert-1], [], [], 'comparing two elements');\n            swap(list, indexToInsert, indexToInsert-1);\n            addStepToTracker(tracker, [...list], [], [], [indexToInsert, indexToInsert-1], 'swapped two elements');\n\n            indexToInsert--;\n        }\n    }\n\n    addStepToTracker(tracker, list, [], getSortedIndicesArray(list.length), [], 'finished sorting');\n    console.log('sorted list: ', list);\n\n    return tracker;\n}\n\nexport const insertionSortInfo = {\n    name: 'Insertion Sort',\n    description: 'Insertion sort is a simple sorting algorithm that iterates through an array and at each iteration it removes one element from the array, finds the location it belongs to in the sorted list and inserts it there, repeating until no elements remain in the unsorted list. It is an in-place, stable sorting algorithm that is inefficient on large input arrays but works well for data sets that are almost sorted. It is more efficient in practice compared to other quadratic sorting algorithms like bubble sort and selection sort.',\n    performance: {\n        best: 'O(n)',\n        average: 'O(n^2)',\n        worst: 'O(n^2)'\n    },\n    index: 2\n}","export const heapSortInfo = {\n    name: 'Heap Sort',\n    description: 'The last sorting algo I know nothing about other than it uses trees',\n    performance: {\n        best: 'O(nlog n)',\n        average: 'O(nlog n)',\n        worst: 'O(nlog n)'\n    },\n    index: 5\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App.js';\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}